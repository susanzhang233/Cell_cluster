# -*- coding: utf-8 -*-
"""be 565.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oZsUGND-KuWmbKlhXqeKI3K1bGHwD8ya

#BE 565 Homework: Rear-wheel drive in collective cell migration of neural crest

We first import a few packages to use for ploting the Voronoi diagram:
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from scipy.spatial import Voronoi, voronoi_plot_2d
import random
import math
from matplotlib import animation
import plotly.express as px
from statistics import mean
import seaborn as sns

"""### 2) Model Parameters

### 3) Set up random points
"""

def set_random_pts(num_cells = 0, _range = []):
  """set up random vertices(with integers) in an xy-plane in user specified range

    params: num_cells: number of cells that the user wants
            _range: range from which to generate numbers
    return: pts: an array of points with x,y positions
  """
  pts = [ [random.randint(_range[0], _range[1]), random.randint(_range[0], _range[1])] for i in range(num_cells)]
  #print(pts)
  return pts

"""### 4) Set up Voronoi network"""

def set_voronoi(pts):
  """set up voronoi diagram from generated random points in an xy-plane

    params: pts: an array of points with randomly generated x,y positions representing cell centers
            **kwargs: keyword arguments to supply to the Voronoi function
    return: vor: generated voronoi diagram
  """
  vor = Voronoi(pts)
  #fig = voronoi_plot_2d(vor)
  #plt.show()
  return vor

"""adjacency matrix, list"""

def adjacency_matrix(_vor):
  """generate adjacency matrix from ridge points: Indices of the points between which each Voronoi ridge lies
      
      param: _vor: generated voronoi python object
  """
  num_cells = len(_vor.points)
  adj_mx = np.zeros((num_cells,num_cells))
  for i in range(num_cells):
    for r in _vor.ridge_points:
      if r[0] == i:
        adj_mx[i][r[1]] = 1
      if r[1] == i:
        adj_mx[i][r[0]] = 1
  return adj_mx

def adjacency_list(_vor):
  """
      param: _vor: generated voronoi python object
  """
  num_cells = len(_vor.points)
  adj_list = {}
  
  for i in range(num_cells):
    cur_value = []
    for r in _vor.ridge_points:
      if r[0] == i:
        cur_value.append(r[1])
      if r[1] == i:
        cur_value.append(r[0])
    
    adj_list[i] = cur_value
  return adj_list

"""### (5) Determine edge cells"""

# def determine_edge_cell(_vor):
#   """
#     param: _vor: generated voronoi python object

#   """
#   adj_list = adjacency_list(_vor)
#   pts = _vor.points
#   for_return = []
#   flag = False
#   for i in adj_list:#loop over all cells
#     if flag:
#       flag = False
#       for_return.append(1)
#       continue #continue to the next i
#     cur_list = adj_list[i]# all cells that the current cell is adjacent to
#     cur_angle_sum = 0
#     cur_edge_calculated = []
#     for _ in cur_list: #loop over all adjacent cells of current cell
#       if flag:
#         break #continue to the next i
#       for o in cur_list:#loop over all adj cells again
#         if o == _:
#           continue
#         if [o,_] in cur_edge_calculated or [_,o] in cur_edge_calculated: #if calculated
#           continue
#         if o in adj_list[ _ ]:#if adjacent
#         #calculate angle btw oi_ (angle abc) and add to angle sum
#           ba = np.array(pts[_]) - np.array(pts[i])
#           bc = np.array(pts[o]) - np.array(pts[i])
#           cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
#           cur_angle = np.arccos(cosine_angle)#np.degrees(angle)) 
          
#           if cur_angle > 3*math.pi /4: #if any of the angles > 135
#             flag = True
#             break #continue to the next _

#           cur_angle_sum +=cur_angle
#           cur_edge_calculated.append([o,_])
     
      
#     #check if it is edge cell
#     if (2* math.pi - cur_angle_sum) > 3*math.pi /4:
#       for_return.append(1)
#     else:
#       for_return.append(0)

#   return for_return

def determine_edge_cell(_vor):
  """
    param: _vor: generated voronoi python object

  """
  adj_list = adjacency_list(_vor)
  pts = _vor.points
  for_return = []
  flag = False
  for i in adj_list:#loop over all cells
    # if flag:
    #   flag = False
    #   for_return.append(1)
    #   continue #continue to the next i
    cur_list = adj_list[i]# all cells that the current cell is adjacent to
    #cur_angle_sum = 0
    cur_angles = []
    cur_edge_calculated = []
    for _ in cur_list: #loop over all adjacent cells of current cell
      # if flag:
      #   break #continue to the next i
      for o in cur_list:#loop over all adj cells again
        if o == _:
          continue
        if [o,_] in cur_edge_calculated or [_,o] in cur_edge_calculated: #if calculated
          continue
        if o in adj_list[ _ ]:#if adjacent
        #calculate angle btw oi_ (angle abc) and add to angle sum
          ba = np.array(pts[_]) - np.array(pts[i])
          bc = np.array(pts[o]) - np.array(pts[i])
          cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
          cur_angle = np.arccos(cosine_angle)#np.degrees(angle)) 
          
          # if cur_angle > 3*math.pi /4: #if any of the angles > 135
          #   flag = True
          #   break #continue to the next _

          #cur_angle_sum +=cur_angle
          cur_angles.append(cur_angle)
          cur_edge_calculated.append([o,_])
     
      
    #check if it is edge cell
    cur_angles.append(2* math.pi - np.sum(cur_angles) )

    if np.max(cur_angles) > 3*math.pi /4:
      for_return.append(1)
    else:
      for_return.append(0)

  return for_return

"""### 6) Update force balances"""

def compute_distance_matrix(_vor):
  adj_mx = adjacency_matrix(_vor)
  dist_mx = []
  cur_dist = []
  for i in range(len(adj_mx)):
    for j in range(len(adj_mx)):
      if adj_mx[i][j] == 0:
        cur_dist.append(0)
      else:
        #calculate distance
        dist = np.sqrt( (_vor.points[i][0] - _vor.points[j][0])**2 + (_vor.points[i][1] - _vor.points[j][1])**2 )
        cur_dist.append(dist)
    dist_mx.append(cur_dist)
    cur_dist = []
  return dist_mx

"""next generate various forces between cells"""

def update_intercell_force(cell_idx, cell_pos, contr, v , r_n, r_a, r_c, r_r, F_c, F_n, F_p, s, F_rep, F_att, delta, adj_lst, contr_or_not):
  """calculate force balance for the cell
  """
  #compute_distance_matrix(_vor)
  #adj_lst = adjacency_list(_vor)
  #edge_or_not = determine_edge_cell(_vor.points, adj_lst) 
  # fi:
  f_i = 0
  f_r_cur = 0
  f_i_cur = 0
  #cur_list = adj_lst[cell_idx] #index of cells that the current cell is adjacent to
  #for i in adj_lst:
  for i in adj_lst[cell_idx]:
    f_r_cur = 0
    f_i_cur = 0
    r = np.sqrt( (cell_pos[cell_idx][0] - cell_pos[i][0])**2 + (cell_pos[cell_idx][1] - cell_pos[i][1])**2 )
    if r<r_c:
      f_r_cur = F_rep * (r - r_c) / np.abs(r_c)
    elif r>= r_n or r< r_a:
      f_r_cur = F_att * (r - r_n) / np.abs(r_a - r_n)
    elif r>= r_a or r< r_r:
      f_r_cur = F_att * (r_r - r) / np.abs(r_r - r_a)
    else:
      f_r_cur = 0
    #print(( cell_pos[i] - cell_pos[cell_idx]) / r)
    if contr == 2:
      contr = 0
    f_i_cur = (f_r_cur + contr * contr_or_not[i] * F_c) * ( cell_pos[i] - cell_pos[cell_idx]) / r
    f_i += f_i_cur
  
  #f(p)a:
 #print(f_i)
  v=np.array( v )

  if np.sqrt(v[0]**2 +v[1]**2) == 0:
    f_p = 0#F_p *s # 0 #F_p * ( s - np.abs(v) ) * v / np.abs(v)
  else:
    f_p = F_p * ( s - np.sqrt(v[0]**2 +v[1]**2) ) * v / np.sqrt(v[0]**2 +v[1]**2)

  #print(f_p)
 # ݂௡ = ܨ௡ ⋅ߦ, where ߦis a zero-mean Wiener process
  f_n = (1 - 2 * np.random.rand(2) ) * F_n
  #print(v)
  return f_i + f_p +f_n - delta *np.array(v) #vector containing position update

"""### 7) Iterate cell velocity and position"""

def run(timesteps, t, verbose, _range, num_cells, mode, r_c = 10):
  """
    :param mode: 0: all not contractile; 1: all border cells are contractile; 2: only border cells 
      on one side of the tissue are contractile

  """
  pts = set_random_pts(num_cells, _range = _range)
  _vor = set_voronoi(pts)
  cells = _vor.points # storing cell positions
  adj_lst = adjacency_list(_vor)
  edge_or_not = np.array(determine_edge_cell(_vor) )
  #cell_pos_eachstep = []
  x = []
  y = []
  cur_x = []
  cur_y = []
  edge = []
  contract_vector = []
  cell_group_color = []
  #contract_or_not = 
  cell_v = np.zeros((len(cells),2)) #all cells's intial velocity
  

  for step in range(timesteps):
    _vor = set_voronoi(cells)
    adj_lst = adjacency_list(_vor)
    edge_or_not = np.array( determine_edge_cell(_vor) )
    #print(edge_or_not)
    contract_vector = np.array(edge_or_not)

    if mode == 0:
      contract_vector = np.zeros(num_cells)
      #cell_group_color.append(edge_or_not)
    elif mode == 1:
      contract_vector = edge_or_not
    
    elif mode == 2:
      center_x = sum(cur_x) / num_cells

      for cell_idx in range(len(cells)): #get contractility vector
        if edge_or_not[cell_idx] == 1: #if edge cell
          if cells[cell_idx][0] >  center_x:
            contract_vector[cell_idx] = 2 #edge cell that contract
            edge_or_not[cell_idx] = 2

    if step%2 ==0: # contractility
      for cell_idx in range(len(cells)):
        v_prime = update_intercell_force(cell_idx =cell_idx, cell_pos = cells, contr = contract_vector[cell_idx], 
                        v=cell_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
                        F_c = 10, F_n = 5, F_p = 5, s =2, F_rep = 5, F_att = 0.5, delta = 0.1, 
                        adj_lst = adj_lst, contr_or_not=contract_vector)
        
        cell_v[cell_idx] = cell_v[cell_idx] + t* v_prime #v' = v+at
        cells[cell_idx] = cells[cell_idx] + t * cell_v[cell_idx] #x' = x+vt
      
      if mode == 0:
        cell_group_color.append(edge_or_not)
      if mode == 1:
        cell_group_color.append(np.where( edge_or_not ==1, edge_or_not+1, edge_or_not))
        
      if mode == 2:
        cell_group_color.append(edge_or_not)
        
    else:
      for cell_idx in range(len(cells)):
        v_prime = update_intercell_force(cell_idx =cell_idx, cell_pos = cells, contr = 0, 
                        v=cell_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
                        F_c = 5, F_n = 5, F_p = 5, s =2, F_rep = 5, F_att = 0.5, delta = 0.1, 
                        adj_lst = adj_lst, contr_or_not=np.zeros(num_cells))
        
        cell_v[cell_idx] = cell_v[cell_idx] + t* v_prime #v' = v+at
        cells[cell_idx] = cells[cell_idx] + t * cell_v[cell_idx] #x' = x+vt
      
      cell_group_color.append(edge_or_not)

    #cell_group_color.append(edge_or_not)
      

  #plot:
    #print(cells)
    #cell_pos_eachstep.append(cells)
    cur_x, cur_y = zip(*cells)
    x.append(cur_x)
    y.append(cur_y)

  return x,y, cell_group_color

"""### 8) Plots"""

timesteps =300
num_cells = 25
x_, y_ ,contr = run(timesteps =timesteps, t = 0.3, r_c = 8, _range = [-5,5], num_cells = num_cells, verbose = 20, mode = 0)

df = pd.DataFrame({'x':np.array(x_).reshape(timesteps* num_cells), 'y': np.array(y_).reshape(timesteps* num_cells) })
time_step_array = np.stack( np.ones(( num_cells,timesteps)) *np.array(range(timesteps)), axis = -1 ).reshape(num_cells*timesteps)
df['t'] = time_step_array
df['cell_marker'] = np.reshape(np.ones(( timesteps,num_cells)) * np.array(range(num_cells)),(timesteps*num_cells) )
df['contr'] = np.reshape(contr, (num_cells*timesteps, 1))

#df = px.data.gapminder()
fig = px.scatter(df, x="x", y="y", animation_frame="t",
            animation_group="cell_marker",
           #size="pop", 
           color="contr", 
           #hover_name="country",
           #log_x=True, 
           #size='t', 
           range_x=[-100,100], range_y=[-50,50],
           title = 'no edge cells contractile'
           )
fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 3

fig.update_traces(marker=dict(size=40,
                              showscale=False,
                              #color = 'LightSkyBlue',
                              line=dict(width=1,
                                        color='DarkSlateGrey')),
                  selector=dict(mode='markers'))

fig.update(layout_coloraxis_showscale=False)

timesteps =300
num_cells = 25
x_, y_ ,contr = run(timesteps =timesteps, t = 0.3, r_c = 8, _range = [-5,5], num_cells = num_cells, verbose = 20, mode = 1)

df = pd.DataFrame({'x':np.array(x_).reshape(timesteps* num_cells), 'y': np.array(y_).reshape(timesteps* num_cells) })
time_step_array = np.stack( np.ones(( num_cells,timesteps)) *np.array(range(timesteps)), axis = -1 ).reshape(num_cells*timesteps)
df['t'] = time_step_array
df['cell_marker'] = np.reshape(np.ones(( timesteps,num_cells)) * np.array(range(num_cells)),(timesteps*num_cells) )
df['contr'] = np.reshape(contr, (num_cells*timesteps, 1))

fig = px.scatter(df, x="x", y="y", animation_frame="t",
            animation_group="cell_marker",
           #size="pop", 
           color="contr", 
           #hover_name="country",
           #log_x=True, 
           #size='t', 
           range_x=[-100,100], range_y=[-50,50],
           title = 'all edge cells contractile'
           )
fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 3

fig.update_traces(marker=dict(size=40,
                              showscale=False,
                              #color = 'LightSkyBlue',
                              line=dict(width=1,
                                        color='DarkSlateGrey')),
                  selector=dict(mode='markers'))

fig.update(layout_coloraxis_showscale=False)

df

timesteps =300
num_cells = 25
x_, y_ ,contr = run(timesteps =timesteps, t = 0.3, r_c = 8, _range = [-5,5], num_cells = num_cells, verbose = 20, mode = 2)

df = pd.DataFrame({'x':np.array(x_).reshape(timesteps* num_cells), 'y': np.array(y_).reshape(timesteps* num_cells) })
time_step_array = np.stack( np.ones(( num_cells,timesteps)) *np.array(range(timesteps)), axis = -1 ).reshape(num_cells*timesteps)
df['t'] = time_step_array
df['cell_marker'] = np.reshape(np.ones(( timesteps,num_cells)) * np.array(range(num_cells)),(timesteps*num_cells) )
df['contractility'] = np.reshape(contr, (num_cells*timesteps, 1))
df["contractility"] = df["contractility"].astype(str)
fig = px.scatter(df, x="x", y="y", animation_frame="t",
            animation_group="cell_marker",
           #size="pop", 
           color="contractility", 
           #hover_name="country",
           #log_x=True, 
           #size='t', 
           range_x=[-100,100], range_y=[-50,50],
           title = 'one edge contractile, no channel',
           category_orders = {"contractility":[1,2,0]},
           color_discrete_map={ # replaces default color mapping by value
                "1": px.colors.qualitative.Plotly[1], "0": px.colors.qualitative.Plotly[2], '2':px.colors.qualitative.Plotly[0]
            },
           )
newnames = {'1':'contractile edge cells', '0': 'non-contractile inner cells', '2':'non-contractile edge cells'}
fig.for_each_trace(lambda t: t.update(name = newnames[t.name],
                                      legendgroup = newnames[t.name],
                                      hovertemplate = t.hovertemplate.replace(t.name, newnames[t.name])
                                     )
                  )
fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 3
fig.update_traces(marker=dict(size=36,
                              opacity = 0.8,
                              #showscale=False,
                              #color = 'LightSkyBlue',
                              line=dict(width=1,
                                        color='white')),
                  selector=dict(mode='markers'))
#fig.update_layout(showlegend=True)
fig.update(layout_coloraxis_showscale=False)

"""## 9 How does confining the cluster within a virtual channel of different widths change its average speed? """

def channel_run(timesteps, t, verbose, _range, num_cells, mode, width, cell_radius = 5, r_c = 10):
  """
    :param mode: 0: all not contractile; 1: all border cells are contractile; 2: only border cells 
      on one side of the tissue are contractile

  """
  pts = set_random_pts(num_cells, _range = _range)
  _vor = set_voronoi(pts)
  cells = _vor.points # storing cell positions
  adj_lst = adjacency_list(_vor)
  edge_or_not = np.array(determine_edge_cell(_vor) )
  x = []
  y = []
  cur_x = []
  cur_y = []
  edge = []
  contract_vector = []
  cell_group_color = []
  center_x_output = []
  cell_v = np.zeros((len(cells),2)) #all cells's intial velocity
  cell_v_scalar = np.zeros((len(cells)))
  last_cells_pos = []
  average_speed_output = []
  
  for step in range(timesteps):
    _vor = set_voronoi(cells)
    adj_lst = adjacency_list(_vor)
    edge_or_not = np.array( determine_edge_cell(_vor) )
    contract_vector = np.array(edge_or_not)

    if mode == 0:
      contract_vector = np.zeros(num_cells)
    elif mode == 1:
      contract_vector = edge_or_not
    elif mode == 2:
      center_x = sum(cur_x) / num_cells

      for cell_idx in range(len(cells)): #get contractility vector
        if edge_or_not[cell_idx] == 1: #if edge cell
          if cells[cell_idx][0] >  center_x:
            contract_vector[cell_idx] = 2 #edge cell that contract
            edge_or_not[cell_idx] = 2

    if step%2 ==0: # contractility
      for cell_idx in range(len(cells)):
        v_prime = update_intercell_force(cell_idx =cell_idx, cell_pos = cells, contr = contract_vector[cell_idx], 
                        v=cell_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
                        F_c = 10, F_n = 5, F_p = 5, s =2, F_rep = 5, F_att = 0.5, delta = 0.1, 
                        adj_lst = adj_lst, contr_or_not=contract_vector)
        
        cell_v[cell_idx] = cell_v[cell_idx] + t * v_prime #v' = v+at
        cell_v_scalar[cell_idx] = np.sqrt(cell_v[cell_idx][0]**2 + cell_v[cell_idx][1]**2)
        #old_pos = cells[cell_idx]
        cells[cell_idx] = cells[cell_idx] + t * cell_v[cell_idx] #x' = x+vt
      
      #colorcode
      if mode == 0:
        cell_group_color.append(edge_or_not)
      if mode == 1:
        cell_group_color.append(np.where( edge_or_not ==1, edge_or_not+1, edge_or_not))      
      if mode == 2:
        cell_group_color.append(edge_or_not)
        
    else: #none contractile steps
      for cell_idx in range(len(cells)):
        v_prime = update_intercell_force(cell_idx =cell_idx, cell_pos = cells, contr = 0, 
                        v=cell_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
                        F_c = 5, F_n = 5, F_p = 5, s =2, F_rep = 5, F_att = 0.5, delta = 0.1, 
                        adj_lst = adj_lst, contr_or_not=np.zeros(num_cells))
        
        cell_v[cell_idx] = cell_v[cell_idx] + t* v_prime #v' = v+at
        cell_v_scalar[cell_idx] = np.sqrt(cell_v[cell_idx][0]**2 + cell_v[cell_idx][1]**2)
        cells[cell_idx] = cells[cell_idx] + t * cell_v[cell_idx] #x' = x+vt
       
      cell_group_color.append(edge_or_not)

    #update position if bounced to tube:
    for cell_idx in range(len(cells)):
      if cells[cell_idx][1] > (width-cell_radius) or cells[cell_idx][1] < (-width+cell_radius):
        real_v = np.array(cell_v[cell_idx]) * [1,-1]
        cell_v[cell_idx] = real_v
        
        cells[cell_idx][1] = last_cells_pos[cell_idx][1]
        
    #print(cells,last_cells_pos)
    last_cells_pos = cells.copy()
  #plot:
    cur_x, cur_y = zip(*cells)
    x.append(cur_x)
    y.append(cur_y)
    center_x_output.append(sum(cur_x) / num_cells)
    cur_average_speed = mean(cell_v_scalar)
    average_speed_output.append(cur_average_speed)

  return x,y, cell_group_color, center_x_output, average_speed_output

timesteps =300
num_cells = 25
x_, y_ ,contr, pos, avspeed = channel_run(timesteps =timesteps, t = 0.3, r_c = 8, _range = [-2,2], num_cells = num_cells, width = 20,verbose = 20, mode = 0)

df = pd.DataFrame({'x':np.array(x_).reshape(timesteps* num_cells), 'y': np.array(y_).reshape(timesteps* num_cells) })
time_step_array = np.stack( np.ones(( num_cells,timesteps)) *np.array(range(timesteps)), axis = -1 ).reshape(num_cells*timesteps)
df['t'] = time_step_array
df['cell_marker'] = np.reshape(np.ones(( timesteps,num_cells)) * np.array(range(num_cells)),(timesteps*num_cells) )
df['contractility'] = np.reshape(contr, (num_cells*timesteps, 1))
df["contractility"] = df["contractility"].astype(str)
fig = px.scatter(df, x="x", y="y", animation_frame="t",
            animation_group="cell_marker",
           #size="pop", 
           color="contractility", 
           #hover_name="country",
           #log_x=True, 
           #size='t', 
           range_x=[-100,100], range_y=[-50,50],
           title = 'all edge contractile within virtual channel of width 20',
           category_orders = {"contractility":[1,0]},
           color_discrete_map={ # replaces default color mapping by value
                "1": px.colors.qualitative.Plotly[1], "0": px.colors.qualitative.Plotly[2]
            },
           
           )
newnames = {'1':'contractile edge cells', '0': 'non-contractile inner cells', '2':'non-contractile edge cells'}
fig.for_each_trace(lambda t: t.update(name = newnames[t.name],
                                      legendgroup = newnames[t.name],
                                      hovertemplate = t.hovertemplate.replace(t.name, newnames[t.name])
                                     )
                  )
fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 3

fig.update_traces(marker=dict(size=36,
                              opacity = 0.8,
                              #color_continuous_scale = 'Mint',
                              #showscale=False,
                              #color = 'LightSkyBlue',
                              line=dict(width=1,
                                        color='white')),
                  selector=dict(mode='markers'),
                  #opacity = 0.8,
                  #color_continuous_scale = 'Mint'
                  )

fig.update(layout_coloraxis_showscale=False)

timesteps =300
num_cells = 25
x_, y_ ,contr, pos, avspeed = channel_run(timesteps =timesteps, t = 0.3, r_c = 8, _range = [-2,2], num_cells = num_cells, width = 20,verbose = 20, mode = 2)

df = pd.DataFrame({'x':np.array(x_).reshape(timesteps* num_cells), 'y': np.array(y_).reshape(timesteps* num_cells) })
time_step_array = np.stack( np.ones(( num_cells,timesteps)) *np.array(range(timesteps)), axis = -1 ).reshape(num_cells*timesteps)
df['t'] = time_step_array
df['cell_marker'] = np.reshape(np.ones(( timesteps,num_cells)) * np.array(range(num_cells)),(timesteps*num_cells) )
df['contractility'] = np.reshape(contr, (num_cells*timesteps, 1))
df["contractility"] = df["contractility"].astype(str)
fig = px.scatter(df, x="x", y="y", animation_frame="t",
            animation_group="cell_marker",
           #size="pop", 
           color="contractility", 
           #hover_name="country",
           #log_x=True, 
           #size='t', 
           range_x=[-100,100], range_y=[-50,50],
           title = 'one edge contractile within virtual channel of width 20',
           category_orders = {"contractility":[1,0,2]},
           color_discrete_map={ # replaces default color mapping by value
                "1": px.colors.qualitative.Plotly[1], "0": px.colors.qualitative.Plotly[2], '2':px.colors.qualitative.Plotly[0]
            },
           
           )
newnames = {'1':'contractile edge cells', '0': 'non-contractile inner cells', '2':'non-contractile edge cells'}
fig.for_each_trace(lambda t: t.update(name = newnames[t.name],
                                      legendgroup = newnames[t.name],
                                      hovertemplate = t.hovertemplate.replace(t.name, newnames[t.name])
                                     )
                  )
fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 3

fig.update_traces(marker=dict(size=36,
                              opacity = 0.8,
                              #color_continuous_scale = 'Mint',
                              #showscale=False,
                              #color = 'LightSkyBlue',
                              line=dict(width=1,
                                        color='white')),
                  selector=dict(mode='markers'),
                  #opacity = 0.8,
                  #color_continuous_scale = 'Mint'
                  )

fig.update(layout_coloraxis_showscale=False)

"""##9 plot"""

#general plot

timesteps = 300
num_cells = 25
x_, y_ ,contr, position, avspeed= channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], num_cells = num_cells, width = 100,verbose = 20, mode = 2)#no boundary
x_, y_ ,contr, position_bounded, avspeed_bounded = channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], 
                                                               num_cells = num_cells, width = 10,verbose = 20, mode = 2)
x_, y_ ,contr, position_1, avspeed_1= channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], 
                                                               num_cells = num_cells, width = 20,verbose = 20, mode = 1)#within boundary

mean(avspeed)

v_nochannel = []
v_channel_20 = []
move_nochannel = []
move_channel_20 = []
for i in range(10):
    x, y ,contr, position, avspeed= channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], num_cells = num_cells, width = 100,verbose = 20, mode = 2)#no boundary
    x, y,contr, position_bounded, avspeed_bounded = channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], 
                                                               num_cells = num_cells, width = 10,verbose = 20, mode = 2)#no boundary
    v_nochannel.append(mean(avspeed))
    v_channel_20.append(mean(avspeed_bounded))  
    move_nochannel.append(position[-1])
    move_channel_20.append(position_bounded[-1])

mean(move_nochannel), mean(move_channel_20)

mean( v_nochannel),mean( v_channel_20)

"""|      |    cluster average position in the end   | intracluster force average velocity| 
|-----------------------------------------------------|----------------------------------|-------|
| No channel   |         64.40          |    2.50          |                                  | 
| With channel (width 20)   |66.88 |      3.04                                
"""

fig, ax = plt.subplots(figsize = (14,7))
plt.plot(range(timesteps), np.array((position,position_bounded,position_1)).T)
ax.legend(['no channel, one edge contractile','with channel, one edge contractile' ,'within channel, no edge cell contractile'], prop={'size': 15})
plt.title( 'cluster position over t with or without channel', fontsize = 18) 
plt.xlabel("timesteps (t)",fontsize = 18)
plt.ylabel("cluster center position (x)",fontsize = 18)
plt.show()

df = pd.DataFrame(np.array((avspeed,avspeed_bounded)).T, columns = ['no channel', 'with channel'])
dfm = df.melt( var_name='widths', value_name='cluster average speed',ignore_index=False)
dfp = dfm.pivot(columns='widths', values='cluster average speed')
dfm.index.name = 'timesteps'
dfm = dfm.reset_index()

g = sns.FacetGrid(dfm, row="widths", sharex=True, height = 3, aspect = 4, hue='widths')
g.map(sns.lineplot, 'timesteps', "cluster average speed")
#g.add_legend()
#g.tight_layout()
g.fig.suptitle('Cluster average speed over different channel width', y = 1.05)
#g.set_titles('Cluster average speed over different channel width')

axes = g.axes.flatten()

for i, ax in enumerate(axes):
  cur_mean = mean( dfp.iloc[:,i] )
  ax.axhline(cur_mean, ls='--', c='grey')
  ax.text(200, cur_mean +0.5 , "average = " + '%.2f' % cur_mean, c='black')

# different width

timesteps = 200
num_cells = 25

positions = []
average_speeds = []
width_label = [6,10,20,50]
#width_label = np.linspace(5,20,4) #note: width could not be broader than position of the cells generated
for i in width_label:
  x_, y_ ,contr, position, avspeed= channel_run(timesteps = timesteps, t = 0.3, r_c = 8, _range = [-2,2], num_cells = num_cells, width = i,verbose = 20, mode = 2)
  positions.append(position)
  average_speeds.append(avspeed)

df = pd.DataFrame(np.array(average_speeds).T, columns = width_label)

dfm = df.melt( var_name='widths', value_name='cluster average speed',ignore_index=False)
dfp = dfm.pivot(columns='widths', values='cluster average speed')
dfm.index.name = 'timesteps'
dfm = dfm.reset_index()

g = sns.FacetGrid(dfm, row="widths", sharex=True, height = 3, aspect = 4, hue='widths')
g.map(sns.lineplot, 'timesteps', "cluster average speed")
#g.add_legend()
#g.tight_layout()
g.fig.suptitle('Cluster average speed over different channel width', y = 1.05)
#g.set_titles('Cluster average speed over different channel width')

axes = g.axes.flatten()

for i, ax in enumerate(axes):
  cur_mean = mean( dfp.iloc[:,i] )
  ax.axhline(cur_mean, ls='--', c='grey')
  ax.text(200, cur_mean +0.5 , "average = " + '%.2f' % cur_mean, c='black')



















fig = px.area(dfp, facet_col='widths', facet_col_wrap=2)
fig.show()

fig, ax = plt.subplots(figsize = (28,7))
plt.plot(range(timesteps), np.array(average_speeds).T)
ax.legend(width_label)
plt.title( 'cluster average speed over t at different channel width') 
plt.xlabel("timesteps (t)")
plt.ylabel("cluster average speed")
plt.show()





fig, ax = plt.subplots(figsize = (14,7))
plt.plot(range(timesteps), np.array(positions).T)
ax.legend(width_label)
plt.title( 'cluster position over t at different channel width') 
plt.xlabel("timesteps (t)")
plt.ylabel("cluster center position (x)")
plt.show()



















################drafts:

# def run(timesteps, t, verbose, _range, num_cells, r_c = 10):
#   pts = set_random_pts(num_cells, _range = _range)
#   _vor = set_voronoi(pts)
#   cells = _vor.points # storing 
#   adj_lst = adjacency_list(_vor)
#   edge_or_not = determine_edge_cell(_vor) 

#   #contract_or_not = 
#   new_v = np.zeros((len(cells),2)) #all cells's intial velocity

#   for step in range(timesteps):
#     if step<100 or step >200: # contractility
#       for cell_idx in range(len(cells)):
#         delta_v = update_intercell_force(cell_idx =cell_idx, _vor = _vor, contr = edge_or_not[cell_idx], 
#                         v=new_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
#                         F_c = 5, F_n = 5, F_p = 5, s =2, F_rep = 10, F_att = 0.5, delta = 0.1, 
#                         adj_lst = adj_lst, edge_or_not=edge_or_not)
#         new_v[cell_idx] = new_v[cell_idx] + delta_v
#         cells[cell_idx] = cells[cell_idx] + t * new_v[cell_idx]
        
#     else:
#       for cell_idx in range(len(cells)):
#         delta_v = update_intercell_force(cell_idx =cell_idx, _vor = _vor, contr = 0, 
#                         v=new_v[cell_idx] , r_n=1.5*r_c, r_a = 1.534*r_c , r_c= r_c, r_r = 1.834*r_c,
#                         F_c = 5, F_n = 5, F_p = 5, s =2, F_rep = 10, F_att = 0.5, delta = 0.1, 
#                         adj_lst = adj_lst, edge_or_not=edge_or_not)
#         new_v[cell_idx] = new_v[cell_idx] + delta_v
#         cells[cell_idx] = cells[cell_idx] + t * new_v[cell_idx] 
#         #update cell position:
#       #cells[cell_idx] = cells[cell_idx] + t * new_v 
#      #new_v += delta_v 

#   #plot:
#     if step%verbose == 0 :
#       fig, ax = plt.subplots()
#       x, y = zip(*cells)
#       plt.scatter(x,y,
#                   #title = 'plot at ' + str(step) + 'iteration'
#                   )
#       plt.title('plot at ' + str(step) + ' iteration')
#     #print(cells)
#   return cells